generic T

use "../stdlib/LibC.shtk" as libc
from "../stdlib/Panic.shtk" use panic

def OUT_OF_BOUNDS_ERROR "Index out of bounds error"
def NULL_POINTER_ERROR "Null pointer dereference error"
def OUT_OF_CAPACITY "Slice out of capacity error"

struct Slice
{
    var _ptr: T[]
    var _capacity: ulong
}

fn slice(ptr: T[], capacity: ulong) -> Slice
{
    var self: Slice
    self._ptr <- ptr
    self._capacity = capacity
    return self
}

fn allocateHeap(capacity: ulong) -> Slice
{
    return slice(T[]`libc::malloc(sizeof(T)*capacity), capacity)
}

fn free(mut self: Slice)
{
    libc::free(ubyte*`self._ptr)
    self._ptr <- T[]`0
}

fn _validateIndex(self: Slice, index: ulong) 
{
    if addr(self._ptr) == 0
        panic(NULL_POINTER_ERROR, 1)
    
    if index >= self._capacity
        panic(OUT_OF_BOUNDS_ERROR, 1)
}

fn _validateLength(self: Slice, length: ulong)
{
    if addr(self._ptr) == 0
        panic(NULL_POINTER_ERROR, 1)
    
    if length > self._capacity
        panic(OUT_OF_CAPACITY, 1)
}

fn subscriptItem(self: Slice, index: ulong) -> T
{
    self._validateIndex(index)

    return self._ptr[index]
}

fn setItem(mut self: Slice, index: ulong, item: T)
{
    self._validateIndex(index)

    self._ptr[index] = item
}

fn capacity(self: Slice) -> ulong
{
    return self._capacity
}

fn copy(self: Slice, items: T[], length: ulong)
{
    self._validateLength(length)
    libc::memcpy(ubyte[]`self._ptr, ubyte[]`items, length*sizeof(T))
}

fn pointer(self: Slice) -> T[]
{
    return self._ptr
}

fn deconstructor(self: Slice)
{
    # TODO should not be called for heap allocated slice

    if not addr(self._ptr) 
        return void

    for var i: ulong = 0; i < self._capacity; i += 1 
        self._ptr[i].deconstructor()
}
use "../stdlib/LibC.shtk" as libc
from "../stdlib/Panic.shtk" use panic
from "../stdlib/String.shtk" use String, string, stringFromPreAllocated
from "../stdlib/Pair.shtk" use Pair, pair
from "../stdlib/Triple.shtk" use Triple, triple
from "../stdlib/Optional.shtk" use Optional, none, some
from "../stdlib/RawPointerUtils.shtk" use nullptrArray
from "../stdlib/Error.shtk" use Error, error, nil
from "../stdlib/ErrorTypes.shtk" use StdlibError, OSError


fn getArg(argv: ulong[], idx: int) -> char[]
{
    # TODO change to String
    return char[]`(argv[idx] + 0)
}

fn panicString(message: String, status: int)
{
    panic(message.toCharArray(), status)
}

fn system(command: String) -> Pair[String, int]
{
    # TODO
    return pair[String, int]("".string(), 0)
}

fn systemWithTimeout(command: String, milliseconds: uint) -> Triple[String, int, bool]
{
    # TODO
    return triple[String, int, bool]("".string(), 0, false)
}

fn getEnv(key: String) -> Optional[String]
{
    # TODO
    return none[String]()
}

fn getcwd() -> Optional[String]
{
    const charArray: char[] <- libc::getcwd(nullptrArray[char](), 0) 

    if not addr(charArray)
        return none[String]()

    const length := libc::strlen(charArray)

    return some[String](stringFromPreAllocated(charArray, length+1, length))
}

fn _intToError(n: int) -> Error[StdlibError]
{
    if n < 0 
        return error[StdlibError](OSError)
    
    return nil[StdlibError]()
}

fn chdir(path: String) -> Error[StdlibError]
{
    return _intToError(libc::chdir(path.toCharArray()))
}

fn mkdir(path: String) -> Error[StdlibError]
{
    return _intToError(libc::mkdir(path.toCharArray(), libc::S_IRWXU | libc::S_IRWXG | libc::S_IROTH | libc::S_IXOTH))
}

fn rmdir(path: String) -> Error[StdlibError]
{
    return _intToError(libc::rmdir(path.toCharArray()))
}

fn rm(path: String) -> Error[StdlibError]
{
    return _intToError(libc::remove(path.toCharArray()))
}
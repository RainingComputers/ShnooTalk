use "../stdlib/LibC.shtk" as libc
from "../stdlib/Optional.shtk" use Optional, none, some
from "../stdlib/String.shtk" use String, string, stringFromPreAllocated
from "../stdlib/RawPointerUtils.shtk" use nullptrArray

enum SeekType {
    SEEK_SET,
    SEEK_CUR,
    SEEK_END
}

struct File
{
    var libcFile: libc::FILE*
}

fn open(path: String, mode: String) -> Optional[File]
{
    var libcFile: libc::FILE* <- libc::fopen(path.toCharArray(), mode.toCharArray())

    if not addr(libcFile)
        return none[File]()

    var self: File
    self.libcFile <- libcFile

    return some[File](self)
}

fn readLine(self: File) -> Optional[String]
{
    var buffer: char[] <- nullptrArray[char]()
    var bufferLength: ulong
    
    const length: long = libc::getline(buffer, bufferLength, self.libcFile)

    if length < 0
        return none[String]()

    return some[String](stringFromPreAllocated(buffer, bufferLength, ulong`length))
}

fn read(self: File) -> String
{
    var contents := "".string()

    loop {
        const [line, err] := self.readLine()
        if err break

        contents = contents + line
    }

    return contents
}

fn seek(self: File, offset: long, whence: SeekType) -> bool
{
    return libc::fseek(self.libcFile, offset, int`whence) < 0
}

fn tell(self: File) -> Optional[long]
{
    const pos := libc::ftell(self.libcFile)

    if pos < 0
        return none[long]()

    return some[long](pos)
}

fn write(self: File, content: String) -> bool
{
    return libc::fputs(content.toCharArray(), self.libcFile) < 0
}

fn close(self: File) -> bool
{
    return libc::fclose(self.libcFile) < 0
}


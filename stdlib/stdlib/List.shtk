generic T

from "../stdlib/Sharedpointer.shtk" use SharedPointer, allocateHeap
from "../stdlib/Optional.shtk" use Optional, some, none
from "../stdlib/RawPointerUtils.shtk" use addOffset
from "../stdlib/Panic.shtk" use panic

def INVALID_RANGE "Invalid range for list range"

struct List
{
    var _sp: SharedPointer[T]
    var _length: ulong
}

fn list(items: T[], length: ulong) -> List
{
    var self: List

    self._sp = allocateHeap(length*2)
    self._sp.copy(items, length)
    self._length = length

    return self
}

fn clone(self: List) -> List
{
    return list(self.pointer(), self.length())
}

fn pointer(self: List) -> T[]
{
    return self._sp.pointer()
}

fn append(mut self: List, item: T)
{
    if self.length() == self.capacity()
        self._sp.expand(self.length()*2)

    self.setItem(self.length(), item)
    self._length += 1
    
}

fn clear(mut self: List)
{
    self._length = 0
}

fn pop(mut self: List) -> T
{
    self._length -= 1
    return self[self._length]
}

fn length(self: List) -> ulong
{
    return self._length
}

fn capacity(self: List) -> ulong
{
    return self._sp.capacity()
}

fn get(self: List, index: ulong) -> Optional[T]
{
    if index < self.length()
        return some(self._sp[index])

    return none()
}

fn setItem(mut self: List, index: ulong, item: T)
{
    self._sp.setItem(index, item)
}

fn __subscriptItem__(self: List, index: ulong) -> T
{
    return self._sp[index]
}

fn __subscriptRange__(self: List, range: ulong[2]) -> List
{
    if range[0] > range[1]
        panic(INVALID_RANGE, 1)

    if range[1] > self.length()
        panic(INVALID_RANGE, 1)

    return list(addOffset[T](self.pointer(), range[0]), range[1] - range[0])
}

fn __addList__(self: List, other: List) -> List
{
    var new := self.clone()

    new._sp.expand((new.length() + other.length())*2)
    new._sp.copyOffset(other.pointer(), other.length(), new.length())
    new._length += other.length()

    return new
}

fn __addArray__(self: List, other: T[], otherLength: ulong) -> List
{
    return self + list(other, otherLength)
}


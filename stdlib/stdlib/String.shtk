use "../stdlib/LibC.shtk" as libc
use "../stdlib/Char.shtk" as char
from "../stdlib/SharedPointer.shtk" use SharedPointer, allocateHeap
from "../stdlib/Slice.shtk" use Slice
from "../stdlib/Optional.shtk" use Optional, some, none

struct String
{
    var _sp: SharedPointer[char]
    var _length: ulong
}

fn string(charArray: char[], lengthIncNull: ulong) -> String
{
    var self: String

    const length := lengthIncNull - 1
    const capacity := length*2 

    self._length = length
    self._sp = allocateHeap[char](capacity)
    self._sp.copy(charArray, lengthIncNull)

    return self
}

fn coerceCharArray(charArray: char[], lengthIncNull: ulong) -> String
{
    return string(charArray, lengthIncNull)
}

fn length(self: String) -> ulong
{
    return self._length
}

fn subscriptItem(self: String, index: ulong) -> char
{
    return self._sp[index]
}

fn toCharArray(self: String) -> char[]
{
    return self._sp.pointer()
}

fn slice(self: String) -> Slice[char]
{
    return self._sp.slice()
}

fn clone(self: String) -> String
{
    return string(self.toCharArray(), self.length()+1)
}

fn isAlphaNumeric(self: String) -> bool
{
    for c in self
        if not char::isAlphaNumeric(c)
            return false

    return true
}

fn isSpace(self: String) -> bool
{
    for c in self
        if not char::isSpace(c)
            return false

    return true
}

fn isUpper(self: String) -> bool
{
    for c in self
        if not char::isUpper(c)
            return false

    return true
}

fn isLower(self: String) -> bool
{
    for c in self
        if not char::isLower(c)
            return false

    return true
}

fn isInteger(self: String) -> bool
{
    for var i: ulong = 0; i < self.length(); i += 1
    {
        if self[i] == '-' and i == 0
            continue
        
        if not char::isDigit(self[i])
            return false
    }

    return true
}

fn isNumber(self: String) -> bool
{
    var dotFound: bool = false

    for var i: ulong = 0; i < self.length(); i += 1
    {
        if self[i] == '-' and i == 0
            continue
        
        if self[i] == '.'
        {
            if dotFound
                return false

            dotFound = true
            continue
        }

        if not char::isDigit(self[i])
            return false
    }

    return true
}

fn lower(self: String) -> String
{
    var new := self.clone()

    for var i: ulong = 0; i < self.length(); i += 1
        new._sp.setItem(i, char::lower(new[i]))

    return new
}

fn upper(self: String) -> String
{
    var new := self.clone()

    for var i: ulong = 0; i < self.length(); i += 1
        new._sp.setItem(i, char::upper(new[i]))

    return new
}

# TODO
# fn split(self: String, delimeter: char) -> List[String]
# {
#     return make(List[String], "")
# }

fn startsWith(self: String, other: String) -> bool
{
    if self.length() < other.length()
        return false

    for var i: ulong = 0; i < other.length(); i += 1
        if self[i] != other[i]
            return false

    return true
}

fn endsWith(self: String, other: String) -> bool
{
    if self.length() < other.length()
        return false
    
    for var i: ulong = self.length(); i >= (self.length() - other.length()); i -= 1
    {
        if self[i] != other[i - other.length()]
            return false    
    }
 
    return true
}

fn find(self: String, subString: String) -> bool
{
    # TODO
    return false
}

fn subString(self: String, range: ulong[2]) -> String
{
    # TODO
    return "".string()
}

fn strip(self: String) -> String
{
    # TODO
    return "".string()
}

fn parseInt(self: String) -> Optional[int]
{
    # TODO
    return none[int]()
}

fn parseLong(self: String) -> Optional[long]
{
    # TODO
    return none[long]()
}

fn parseFloat(self: String) -> Optional[float]
{
    # TODO
    return none[float]()  
}

fn parseDouble(self: String) -> Optional[double]
{
    # TODO
    return none[double]()
}

fn isEqual(self: String, other: String) -> bool
{
    # TODO
    return false
}

fn lessThan(self: String, other: String) -> bool
{
    # TODO
    return false
}

fn plus(self: String, other: String) -> String
{
    # TODO
    return "".string()
}

fn plusEqual(mut self: String, other: String)
{
    # TODO
}
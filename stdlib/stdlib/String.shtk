use "../stdlib/LibC.shtk" as libc
use "../stdlib/Char.shtk" as char
from "../stdlib/SharedPointer.shtk" use SharedPointer, allocateHeap, fromPreAllocated
from "../stdlib/Optional.shtk" use Optional, some, none
from "../stdlib/Panic.shtk" use panic
from "../stdlib/RawPointerUtils.shtk" use addOffset


def INVALID_RANGE "Invalid range for subString"

struct String
{
    var _sp: SharedPointer[char]
    var _length: ulong
}

fn string(charArray: char[], lengthIncNull: ulong) -> String
{
    var self: String

    const length := lengthIncNull - 1
    const capacity := lengthIncNull * 2 

    self._length = length
    self._sp = allocateHeap(capacity)
    self._sp.copy(charArray, lengthIncNull)
    self._sp.setItem(length, '\0')

    return self
}

fn stringFromPreAllocated(charArray: char[], bufferLength: ulong, length: ulong) -> String
{
    var self: String

    self._length = length
    self._sp = fromPreAllocated(charArray, bufferLength)
    
    return self
}

fn __coerceCharArray__(charArray: char[], lengthIncNull: ulong) -> String
{
    return string(charArray, lengthIncNull)
}

fn length(self: String) -> ulong
{
    return self._length
}

fn __subscriptItem__(self: String, index: ulong) -> char
{
    return self._sp[index]
}

fn toCharArray(self: String) -> char[]
{
    return self._sp.pointer()
}

fn __toCharArray__(self: String) -> char[]
{
    return self.toCharArray()
}

fn toCharArrayOffset(self: String, offset: ulong) -> char[]
{
    return addOffset[char](self.toCharArray(), offset)
}

fn clone(self: String) -> String
{
    return string(self.toCharArray(), self.length()+1)
}

fn isAlphaNumeric(self: String) -> bool
{
    for c in self
        if not char::isAlphaNumeric(c)
            return false

    return true
}

fn isSpace(self: String) -> bool
{
    for c in self
        if not char::isSpace(c)
            return false

    return true
}

fn isUpper(self: String) -> bool
{
    for c in self
        if not char::isUpper(c)
            return false

    return true
}

fn isLower(self: String) -> bool
{
    for c in self
        if not char::isLower(c)
            return false

    return true
}

fn isInteger(self: String) -> bool
{
    for var i: ulong = 0; i < self.length(); i += 1
    {
        if self[i] == '-' and i == 0
            continue
        
        if not char::isDigit(self[i])
            return false
    }

    return true
}

fn isNumber(self: String) -> bool
{
    var dotFound: bool = false

    for var i: ulong = 0; i < self.length(); i += 1
    {
        if self[i] == '-' and i == 0
            continue
        
        if self[i] == '.'
        {
            if dotFound
                return false

            dotFound = true
            continue
        }

        if not char::isDigit(self[i])
            return false
    }

    return true
}

fn lower(self: String) -> String
{
    var new := self.clone()

    for var i: ulong = 0; i < self.length(); i += 1
        new._sp.setItem(i, char::lower(new[i]))

    return new
}

fn upper(self: String) -> String
{
    var new := self.clone()

    for var i: ulong = 0; i < self.length(); i += 1
        new._sp.setItem(i, char::upper(new[i]))

    return new
}

# TODO
# fn split(self: String, delimeter: char) -> List[String]
# {
#     return make(List[String], "")
# }

fn startsWith(self: String, other: String) -> bool
{
    if self.length() < other.length()
        return false

    for var i: ulong = 0; i < other.length(); i += 1
        if self[i] != other[i]
            return false

    return true
}

fn endsWith(self: String, other: String) -> bool
{
    if self.length() < other.length()
        return false
    
    const delta := self.length() - other.length()

    for var i: ulong = 0; i < other.length(); i += 1
        if self[i + delta] != other[i]
            return false
 
    return true
}

fn _startsWithOffset(self: String, other: String, offset: ulong) -> bool
{
    for var i: ulong = 0; i < other.length(); i += 1
        if self[i+offset] != other[i]
            return false

    return true
}

fn find(self: String, other: String) -> Optional[ulong]
{
    if self.length() < other.length()
        return none()
    
    for var i: ulong = 0; i <= (self.length() - other.length()); i += 1
        if self._startsWithOffset(other, i)
            return some(i)

    return none()
}


fn __inString__(self: String, other: String) -> bool
{
    for var i: ulong = 0; i <= (self.length() - other.length()); i += 1
        if self._startsWithOffset(other, i)
            return true

    return false
}

fn __inCharArray__(self: String, other: char[], n: ulong) -> bool
{
    return __coerceCharArray__(other, n) in self
}

fn __inChar__(self: String, other: char) -> bool
{
    for var i: ulong = 0; i < self.length(); i += 1
        if self[i] == other
            return true

    return false
}

fn subString(self: String, range: ulong[2]) -> String
{
    if range[0] > range[1]
        panic(INVALID_RANGE, 1)

    if range[1] > self.length()
        panic(INVALID_RANGE, 1)

    const lengthIncNull := range[1] - range[0] + 1
    
    return string(self.toCharArrayOffset(range[0]), lengthIncNull)
}

fn __subscriptSubString__(self: String, range: ulong[2]) -> String
{
    return self.subString(range)
}

fn strip(self: String) -> String
{
    if self.length() == 0
        return self
    
    var start: ulong = 0
    while start < self.length() and char::isSpace(self[start]) 
        start += 1 

    var end: ulong = self.length() - 1
    while end > start and char::isSpace(self[end]) 
        end -= 1 

    return self[[start, end+1]]
}

fn parseInt(self: String) -> Optional[int]
{
    if not self.isInteger()
        return none()

    return some(libc::atoi(self.toCharArray()))
}

fn parseLong(self: String) -> Optional[long]
{
    if not self.isInteger()
        return none()

    return some(libc::atol(self.toCharArray()))
}

fn parseFloat(self: String) -> Optional[float]
{
    if not self.isNumber()
        return none()

    return some(float`libc::atof(self.toCharArray()))
}

fn parseDouble(self: String) -> Optional[double]
{
    if not self.isNumber()
        return none()

    return some(libc::atof(self.toCharArray()))
}

fn __isEqual__(self: String, other: String) -> bool
{
    return libc::strcmp(self.toCharArray(), other.toCharArray()) == 0
}

fn __lessThan__(self: String, other: String) -> bool
{
    return libc::strcmp(self.toCharArray(), other.toCharArray()) < 0
}

fn __lessThanOrEqual__(LHS: String, RHS: String) -> bool
{
    return LHS < RHS or LHS == RHS
}

fn __greaterThan__(self: String, other: String) -> bool
{
    return libc::strcmp(self.toCharArray(), other.toCharArray()) > 0
}

fn __greaterThanOrEqual__(LHS: String, RHS: String) -> bool
{
    return LHS > RHS or LHS == RHS
}

fn __isNotEqual__(LHS: String, RHS: String) -> bool
{
    return not (LHS == RHS)
}

fn __add__(self: String, other: String) -> String
{
    var new := self.clone()
    
    new._sp.expand(self.length() + other.length() + 1)
    new._sp.copyOffset(other._sp.pointer(), other.length() + 1, self.length())
    new._length += other.length()

    return new
}
